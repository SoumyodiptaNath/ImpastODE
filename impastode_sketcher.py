import cv2
import numpy as np
from os.path import join
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from matplotlib.patches import Ellipse
from sklearn.mixture import GaussianMixture

plt.style.use('dark_background')


################################################################################################
################################################################################################


class LocallyWeightedLinearModelColor:    
    def __init__(self,
                 image_size: int,
                 num_colors: int,
                 sim_t_max: float,
                 num_t_steps: int,
                 num_gauss_per_color: int = 2,
                 Omega_Magnitude: float = 1e-2,
                ):
        """
        Initializes the model parameters for generating art from image color dynamics.

        Args:
            image_size (int): The width/height to resize the input image to (square).
            num_colors (int): The number of color clusters (K) for K-Means segmentation.
            sim_t_max (float): The total duration of the ODE simulation for trajectories.
            num_t_steps (int): The number of time steps to record in the output trajectory.
            num_gauss_per_color (int, optional): Maximum number of Gaussian components to fit spatially 
                                                 for each color cluster. Defaults to 2.
            Omega_Magnitude (float, optional): The magnitude of the rotational component in the dynamics.
                                               Higher values create tighter spirals. Defaults to 1e-2.
        """
        self.num_colors = num_colors
        self.image_size = image_size
        self.sim_t_max = sim_t_max
        self.num_t_steps = num_t_steps
        self.omega_mag = Omega_Magnitude
        self.gauss_per_color = num_gauss_per_color


    def extract_color_clusters(self, img: np.ndarray, show_flag: bool = False):
        """
        Performs K-Means clustering on the image pixel colors to segment the image.

        Args:
            img (np.ndarray): Input image in BGR format (standard OpenCV format).
            show_flag (bool, optional): If True, plots the segmented result. Defaults to False.

        Returns:
            color_labels (np.ndarray): A flattened array of size (image_size*image_size,) containing
                                       the cluster index (0 to num_colors-1) for each pixel.
            color_centers (np.ndarray): Array of shape (num_colors, 3) containing the RGB centroid
                                        for each color cluster.
        """
        # Resize to ensure consistent processing scale
        img = cv2.resize(img, (self.image_size, self.image_size))
        cv2.cvtColor(img, cv2.COLOR_BGR2RGB, dst=img)
        
        # Apply slight blur to smooth out noise before clustering, resulting in cleaner regions
        cv2.GaussianBlur(img, (3, 3), sigmaX=1.5, dst=img)

        # Flatten image to a list of pixels (N, 3)
        pixels = img.reshape(-1, 3).astype(np.float32)
        
        # K-Means criteria: Stop after 10 iterations or if epsilon < 1.0
        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 10, 1.0)
        compactness = cv2.KMEANS_PP_CENTERS

        _, color_labels, color_centers = cv2.kmeans(
            pixels, self.num_colors, None,
            criteria, 3, compactness,
        )
        
        color_labels = color_labels.flatten()
        color_centers = color_centers.astype(np.uint8)
        
        # Reconstruct the segmented image for visualization
        self.seg_img = color_centers[color_labels].reshape(self.image_size, self.image_size, 3)

        if show_flag:
            plt.imshow(self.seg_img)
            plt.title("K-Means Color Segmentation")
            plt.tight_layout()
            plt.axis("off")
            
        return color_labels, color_centers
    
    
    def extract_spatial_clusters(self, 
                                 X: np.ndarray, 
                                 color_labels: np.ndarray, 
                                 show_flag: bool = False
                                ):
        """
        Fits Spatial Gaussian Mixture Models (GMM) to the coordinate locations of each color.
        It also computes the 'A' matrices that define the local dynamics (spirals) for each Gaussian.

        Args:
            X (np.ndarray): Normalized (x, y) coordinates of all pixels. Shape (N_pixels, 2).
            color_labels (np.ndarray): Color cluster index for each pixel. Shape (N_pixels,).
            show_flag (bool, optional): If True, displays the vector field generated by the GMMs.

        Returns:
            None: Updates internal state (self.means, self.covs, self.A_matrix, etc.).
        """
        covs_list = []
        means_list = []
        cluster_ids_per_gauss = []

        # Loop through each unique color found by K-Means
        for c in range(self.num_colors):
            # Extract coordinates X where the pixel color is 'c'
            X_c = X[color_labels == c]
            
            # Skip if this color has almost no pixels
            if X_c.shape[0] < 2: continue

            # Fit a GMM to the spatial distribution of this specific color
            n_components = min(self.gauss_per_color, X_c.shape[0])
            gmm = GaussianMixture(n_components=n_components, random_state=0)
            gmm.fit(X_c)

            means_list.append(gmm.means_)
            covs_list.append(gmm.covariances_)
            # Keep track of which color this Gaussian belongs to
            cluster_ids_per_gauss.extend([c] * n_components)

        # Stack lists into monolithic arrays for vectorized ODE computation
        self.means = np.vstack(means_list)
        # Inflate covariance slightly (x2.5) to widen the attraction basins
        self.covs = np.vstack(covs_list) * 2.5
        self.num_gauss = self.means.shape[0]
        self.cluster_ids_per_gauss = np.array(cluster_ids_per_gauss, dtype=int)

        # Precompute inverses and determinants for fast Gaussian PDF evaluation
        dets = np.linalg.det(self.covs)
        self.covs_inv = np.linalg.inv(self.covs)
        self.gaussian_den = 2.0 * np.pi * np.sqrt(dets)

        # --- Construct Dynamics Matrices (A) ---
        self.A_matrix = np.zeros_like(self.covs)
        # Skew-symmetric matrix to induce rotation
        omega = np.array([[0.0, -self.omega_mag],
                          [self.omega_mag, 0.0]])

        for i, cov in enumerate(self.covs):
            # Decompose covariance to align dynamics with the shape of the blob
            eigvals, eigvecs = np.linalg.eigh(cov)
            
            # Create a stable spiral:
            # -np.diag(eigvals) provides stability (attraction to center)
            # +omega provides rotation
            A_local = -np.diag(eigvals) + omega
            
            # Rotate dynamics back to global frame
            self.A_matrix[i] = eigvecs @ A_local @ eigvecs.T
        
        if show_flag:
            self._visualize_vector_field()
            
            
    def _visualize_vector_field(self):
        """
        Helper to plot the generated vector field overlaid with 
        colored ellipses representing the Gaussian components.
        """
        # 1. Generate Vector Field Grid
        xs = np.linspace(0, 1, 25)
        ys = np.linspace(0, 1, 25)
        XX, YY = np.meshgrid(xs, ys)
        U = np.zeros_like(XX)
        V = np.zeros_like(YY)

        # 2. Compute Dynamics at Grid Points
        for i in range(XX.shape[0]):
            for j in range(XX.shape[1]):
                d = self.dynamics_ODE(0.0, np.array([XX[i, j], YY[i, j]]))
                U[i, j], V[i, j] = d

        # 3. Setup Plot
        ax = plt.gca()
        
        # 4. Plot Vector Field (Quiver)
        ax.quiver(XX, YY, U, V, alpha=0.7, color='white', zorder=2)

        # 5. Plot Colored Gaussian Ellipses
        # We iterate over every Gaussian component found in the GMMs
        for k in range(self.num_gauss):
            mean = self.means[k]
            cov = self.covs[k] / 2.5 # Revert the inflation for visualization accuracy
            
            # Calculate eigvals and eigvecs to get ellipse orientation/size
            eigvals, eigvecs = np.linalg.eigh(cov)
            
            # Width and Height are 2 * sqrt(eigenvalue) * n_std_dev
            # We use 2.0 std dev to cover ~95% of the data in that Gaussian
            width = 2.0 * np.sqrt(eigvals[0]) * 2.0 
            height = 2.0 * np.sqrt(eigvals[1]) * 2.0
            
            # Calculate angle of rotation (in degrees for Matplotlib)
            angle = np.degrees(np.arctan2(eigvecs[1, 0], eigvecs[0, 0]))
            
            # Get the color corresponding to this Gaussian
            c_idx = self.cluster_ids_per_gauss[k]
            color_rgb = self.kmeans_colors[c_idx] / 255.0
            
            # Create and add the Ellipse patch
            ell = Ellipse(xy=mean, width=width, height=height, angle=angle, 
                          color=color_rgb, alpha=0.25, zorder=1)
            ax.add_patch(ell)
            
            # Plot the center of the Gaussian
            ax.scatter(mean[0], mean[1], c=[color_rgb], s=20, edgecolor='white', zorder=3)

        ax.set_title("Vector Field with Color-Cluster Gaussians")
        ax.axis("equal")
        ax.axis("off")
        plt.tight_layout()
        
        
    def setup(self, img_path: str, show_flag: bool = False): 
        """
        Orchestrator function: Loads image, extracts color, extracts spatial clusters.

        Args:
            img_path (str): Path to the source image file.
            show_flag (bool, optional): Whether to show intermediate plots. Defaults to False.

        Returns:
            None
        """
        img_bgr = cv2.imread(img_path)
        if img_bgr is None:
            raise FileNotFoundError(f"Image not found at {img_path}")

        if show_flag: plt.figure(figsize=(17, 9)); plt.subplot(1, 2, 1)
        
        # 1. Get colors
        color_labels, self.kmeans_colors = self.extract_color_clusters(img=img_bgr, show_flag=show_flag)
                    
        # Create normalized coordinate grid (0 to 1) for X and Y
        ys, xs = np.indices((self.image_size, self.image_size))
        xs_flat = xs.ravel().astype(np.float32)
        ys_flat = ys.ravel().astype(np.float32)

        x_norm = xs_flat / float(self.image_size)
        # Flip Y so (0,0) is bottom-left for plotting consistency (optional choice)
        y_flip = self.image_size - ys_flat
        y_norm = y_flip / float(self.image_size)
        
        if show_flag: plt.subplot(1, 2, 2)
        
        # 2. Fit spatial models to coordinates
        X_norm = np.stack([x_norm, y_norm], axis=1)
        self.extract_spatial_clusters(X_norm, color_labels, show_flag)
        
        if show_flag: plt.show()
            

    def dynamics_ODE(self, t, X: np.ndarray):
        """
        The derivative function (dX/dt) for the ODE solver.
        Computes a weighted sum of linear dynamics based on Gaussian activation.

        Args:
            t (float): Current time (required by solve_ivp, though unused here as system is autonomous).
            X (np.ndarray): Current position vector [x, y].

        Returns:
            np.ndarray: Velocity vector [u, v].
        """
        # Vectorized Mahalanobis distance calculation
        diff = X - self.means # Shape: (Num_Gauss, 2)
        
        # einsum computes (x-mu)^T * Sigma^-1 * (x-mu) for all Gaussians at once
        quad = np.einsum('kd,kde,ke->k', diff, self.covs_inv, diff)
        
        # Calculate weights. Cubing (**3) sharpens the activation, reducing overlap blending
        gaussian = (np.exp(-0.5 * quad) / self.gaussian_den) ** 3.
        gaussian_sum = np.sum(gaussian)
        
        # Calculate local linear velocity: A_k * (X - mu_k)
        AX = np.einsum('kij,kj->ki', self.A_matrix, diff)
        
        # Avoid division by zero if point is far from all clusters
        if gaussian_sum < 1e-7: return np.zeros_like(X) 
        
        # Weighted average of velocities (Gaussian Mixture Regression)
        return np.sum(gaussian[:, None] * AX, axis=0) / gaussian_sum


    def dominant_cluster_for_point(self, X: np.ndarray) -> int:
        """
        Determines the dominant original color index for a final position X.
        
        Args:
            X (np.ndarray): The query point [x, y].

        Returns:
            int: The index of the color cluster (0 to num_colors-1) that owns 
                 the Gaussian with the highest activation at X.
        """
        diff = X - self.means
        quad = np.einsum('kd,kde,ke->k', diff, self.covs_inv, diff)
        gaussian = np.exp(-0.5 * quad) / self.gaussian_den

        # Sum probabilities per color ID
        weights_per_color = np.bincount(
            self.cluster_ids_per_gauss,
            weights=gaussian,
            minlength=self.num_colors,
        )
        return int(np.argmax(weights_per_color))
        

    def get_trajectory(self, X0):
        """
        Simulates a single particle trajectory starting at X0.

        Args:
            X0 (list or np.ndarray): Start position [x, y].

        Returns:
            Traj (np.ndarray): Array of shape (2, num_t_steps) containing the path.
            color_rgb (np.ndarray): The normalized RGB color (0-1) associated with the 
                                    endpoint of the trajectory.
        """
        Traj = solve_ivp(
            self.dynamics_ODE,
            [0.0, self.sim_t_max],
            X0,
            t_eval=np.linspace(0.0, self.sim_t_max, self.num_t_steps)
        ).y
        
        # Determine color based on where the particle ends up (or dominantly stays)
        c_idx = self.dominant_cluster_for_point(Traj[:, -1])
        color_rgb = self.kmeans_colors[c_idx] / 255.0
        
        return Traj, color_rgb
        

    def test_results(self, density_X0: int, out_path:str=None):
        """
        Generates and plots a grid of trajectories to visualize the overall artistic effect.

        Args:
            density_X0 (int): The square root of the number of particles. 
                              (e.g., 30 creates a 30x30 grid of starting points).
            
            out_path (str): Path to the save image file generated. (Default: None -> Not saved)
        
        Returns:
            None: Displays a Matplotlib figure.
        """
        Traj_List = []
        Colors_List = []
        
        # Generate a grid of starting points
        X0_arr = np.column_stack([
            X.flatten() for X in np.meshgrid(
                np.linspace(0.0, 1.0, density_X0),
                np.linspace(0.0, 1.0, density_X0),
            )
        ])
        
        # Compute trajectories for all points
        for X0 in X0_arr:
            Traj, color_rgb = self.get_trajectory(X0)
            Traj_List.append(Traj)
            Colors_List.append(color_rgb)
        
        # --- Visualization ---
        plt.figure(figsize=(17, 9))
        plt.subplot(1, 2, 1)
        
        for Traj, color_rgb in zip(Traj_List, Colors_List):
            plt.plot(Traj[0], Traj[1], color=color_rgb,  alpha=0.9, linewidth=0.7)
            
        plt.title("Trajectories colored by K-Means color cluster")
        plt.tight_layout()
        plt.axis("equal")
        plt.axis("off")
        
        plt.subplot(1, 2, 2)
        plt.imshow(self.seg_img)
        plt.title("Original K-Means Color Segmentation")
        plt.tight_layout()
        plt.axis("equal")
        plt.axis("off")
        if out_path is not None:
            plt.savefig(out_path, dpi=300)
        plt.show()


    def update_plot_on_hover(self, event):
        """Callback function for interactive mouse movement."""
        # Only react if mouse is inside the trajectory plot (ax[0])
        if event.inaxes != self.ax[0]: return
        if event.xdata is None or event.ydata is None: return
        
        X0 = np.array([event.xdata, event.ydata])
        
        # Calculate and plot single trajectory
        Traj, color_rgb = self.get_trajectory(X0)
        self.ax[0].plot(Traj[0], Traj[1], color=color_rgb, linewidth=0.7, alpha=0.9)
        self.fig.canvas.draw()


    def activate_live_update(self):
        """
        Starts an interactive matplotlib session. 
        Move the mouse over the left panel to generate trajectories in real-time.
        """
        self.fig, self.ax = plt.subplots(1, 2, figsize=(17, 9))
        
        # Left Panel: Canvas for trajectories
        self.ax[0].set_xlim((0., 1.))
        self.ax[0].set_ylim((0., 1.))
        self.ax[0].set_aspect("equal")
        self.ax[0].axis("off")
        self.ax[0].set_title("Hover here to paint trajectories")
        
        # Right Panel: Reference Image
        self.ax[1].imshow(self.seg_img)
        self.ax[1].set_aspect("equal")
        self.ax[1].axis("off")
        
        self.fig.tight_layout()
        # Connect mouse motion event to the callback
        self.fig.canvas.mpl_connect('motion_notify_event', self.update_plot_on_hover)
        plt.show()

        
################################################################################################
################################################################################################


if __name__ == "__main__":
    # Example usage
    LWLM = LocallyWeightedLinearModelColor(
        num_colors=5,             # Segment image into 5 dominant colors
        image_size=500,           # Resize input to 500x500
        sim_t_max=50.0,           # Run simulation for 50 time units
        num_t_steps=50,           # Resolution of trajectory
        num_gauss_per_color=4,    # Each color can have up to 4 spatial clusters
        Omega_Magnitude=2.5e-2,   # Spiral tightness
    )
    
    # Note: Ensure "Scene.jpg" exists in the INPUT_IMAGES or provide full path
    try:
        LWLM.setup(
            img_path=join("INPUT_IMAGES", "Scene.jpg"),
            show_flag=True,       # Show setup plots
        )

        # 1. Start interactive mode
        LWLM.activate_live_update()
        
        # 2. Generate static batch result
        LWLM.test_results(
            density_X0=30,
            out_path=join("OUTPUT_IMAGES", "out.png")
        )
        
    except FileNotFoundError as e:
        print(e)


################################################################################################
################################################################################################

